// ---------------------------------------------------------------------------------
// T E S T B E D 3
//
// Copyright (C) 2023-Present Wesley M. Conner
//
// LICENSE
// Licensed under the Apache License, Version 2.0 (aka Apache-2.0, the
// "License"), see http://www.apache.org/licenses/LICENSE-2.0. You may
// not use this file except in compliance with the License. Unless
// required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// ---------------------------------------------------------------------------------
// For reference:
//   Unicode 2190 ← LEFTWARDS ARROW
//   Unicode 2192 → RIGHTWARDS ARROW

import com.hubitat.app.ChildDeviceWrapper as ChildDevW
import groovy.transform.Field
import java.util.concurrent.ConcurrentHashMap
import java.util.regex.Matcher
import java.util.regex.Pattern

// All three of these tables are keyed by a pattern 'name' (String).
//-> @Field static ConcurrentHashMap<String, Pattern> PATTERNS = [:]
@Field static ConcurrentHashMap<String, ArrayList> MATCHERS = [:]
//@Field static ConcurrentHashMap<String, GString> REPLACER = [:]

// The Groovy Linter generates NglParseError on Hubitat #include !!!
definition(
  name: 'BlockA',
  namespace: 'Wmc',
  author: 'Wesley M. Conner',
  description: 'Develop AsciiDoc-like parsing',
  singleInstance: true,
  iconUrl: '',
  iconX2Url: ''
)

preferences {
  page(name: 'BlockA')
}

Map BlockA() {
  return dynamicPage(
    name: 'BlockA',
    title: 'BlockA',
    install: true,
    uninstall: true
  ) {
    section {
      //paragraph 'Everything happens on installation. Click "Done".'
      processString()
    }
  }
}

// CORE METHODS

// THESE SPECIFIC METHODS WILL BE REFACTORED AND CACHES WILL BE USED.

String replaceTrivial(String s) {
  return s.replaceAll(/\(C\)/, '©')
          .replaceAll(/\(R\)/, '®')
          .replaceAll(/\(TM\)/, '™')
          .replaceAll(/--/, '—')
          .replaceAll(/\.\.\./, '…')
          .replaceAll(/->/, '→')
          .replaceAll(/<-/, '←')
}

Matcher getMatcher(String name) {
  Matcher matcher = MATCHERS[name]
  Boolean encounteredError = false
  if (!matcher) {
    switch (name) {
      case 'Italic':
        matcher = Pattern.compile(/(?s)_(.*?)_/).matcher('')
        break
      case 'Bold':
        matcher = Pattern.compile(/(?mg)(?!^[\*]).*?\*(.*?)\*/).matcher('')
        break
      case 'Mono':
        matcher = Pattern.compile(/(?s)+(.*?)+/).matcher('')
        break
      case 'Superscript':
        matcher = Pattern.compile(/(?s)^(.*?)^/).matcher('')
        break
      case 'Subscript':
        matcher = Pattern.compile(/(?s)~(.*?)~/).matcher('')
        break
      case 'Command':
        matcher = Pattern.compile(/(?s)`(.*?)`/).matcher('')
        break
      case 'Foreground':
        matcher = Pattern.compile(/(?s)\[([^\]]*)\]\#([^#]*?)\#/).matcher('')
        break
      case 'Background':
        matcher = Pattern.compile(/(?s)\[([^\]]*)-background\]\#([^#]*)\#/).matcher('')
        break
      case 'Big':
        matcher = Pattern.compile(/(?s)\[big\]\#([^\]]*)\#/).matcher('')
        break
      case 'Huge':
        matcher = Pattern.compile(/(?s)\[huge\]\#([^\]]*)\#/).matcher('')
        break
      default:
        encounteredError = true
    }
    if (!encounteredError) { MATCHERS[name] = matcher }
  }
  return matcher
}

/*
  // MATCHERS['Level1'] = [//, ""]
  // MATCHERS['Level2'] = [//, ""]
  // MATCHERS['Level3'] = [//, ""]
  // MATCHERS['ParaTitle'] = [//, ""]
  // MATCHERS['Para'] = [//, ""]
  // MATCHERS['Literal'] = [//, ""]
  // MATCHERS['Note'] = [//, ""]
  // MATCHERS['Tip'] = [//, ""]
  // MATCHERS['Important'] = [//, ""]
  // MATCHERS['Warning'] = [//, ""]
  // MATCHERS['Caution'] = [//, ""]
  // MATCHERS['ListingBlock'] = [//, ""]
  // MATCHERS['SidebarBlock'] = [//, ""]
  // MATCHERS['ExampleBlock'] = [//, ""]
  // MATCHERS['LiteralBlock'] = [//, ""]
  // MATCHERS['QuoteBlock'] = [//, ""]
  // MATCHERS['AsIs'] = [//, ""]
  // MATCHERS['LineBreak'] = [//, ""]
  // MATCHERS['HBar'] = [//, ""]
  // MATCHERS['TermWithDefn'] = [//, ""]
  // MATCHERS['HorzTermWithDefn'] = [//, ""]
  // MATCHERS['QandA'] = [//, ""]
  // MATCHERS['Table'] = [//, ""]
  // MATCHERS['CSV'] = [//, ""]
*/

String matchAndReplace(String sArg) {
  String s = sArg
  ArrayList targets = [ 'Italic' /*, 'Bold'*/ ]
  targets.forEach{ target ->
    Matcher m = getMatcher(target)
    // VERY IMPORTANT:
    //   - DO NOT USE "if (m) { ... }" WHICH RETURNS TRUE IF THE ASSOCIATED
    //     PATTERN MATCHES THE CURRENT STRING (initialized to null).
    //   - INSTEAD, USE "if (m != null) { ... }" WHICH CONFIRMS THE MATCHER
    //     EXISTS AND CAN ACCEPT A NEW STRING VIA reset(String s).
    if (m != null) {
      m.reset(s)
      ArrayList revisedS = []
      String carryover = ''
      Integer iterationStart = 0
      while (m.find()) {
        String before = s.substring(iterationStart, m.start())
        String replacer
        switch (target) {
          case 'Italic':
            replacer = "<em>${m.group(1)}</em>"
            break
          case 'Bold':
            replacer = "<b>${m.group(1)}</b>"
            break
          case 'Mono':
            replacer = "<tt>${m.group(1)}</tt>"
            break
          case 'Superscript':
            replacer = "<sup>${m.group(1)}</sub>"
            break
          case 'Subscript':
            replacer = "<sub>${m.group(1)}</sub>"
            break
          case 'Command':
            replacer = "<code>${m.group(1)}</code>"
            break
          case 'Foreground':
            replacer = "<span style: 'color: ${m.group(1)};'>${m.group(2)}</span>"
            break
          case 'Background':
            replacer = "<span style: 'background: ${m.group(1)};'>${m.group(2)}</span>"
            break
          case 'Big':
            replacer = "<span style: 'font-size: 1.1em;'>${m.group(1)}</span>"
            break
          case 'Huge':
            replacer = "<span style: 'font-size: 1.3em;'>${m.group(1)}</span>"
            break
          default:
            encounteredError = true
        }
        carryover = s.substring(m.end(), m.regionEnd())
        iterationStart = m.end()
        // Process replacer GString HERE - with access to the current m.find().
        paragraph([
          "<table border='1'><tr><th>before</th><td>${summarizeString(before)}</td></tr>",
          "<tr><th>replacer</th><td>${replacer}</td></tr>",
          "<tr><th>carryover</th><td>${summarizeString(carryover)}</td></tr></table>",
        ].join('<br/>'))
        revisedS << before
        revisedS << replacer
      }
      revisedS << carryover
      paragraph([
        '--------------------------------------------------',
        "AFTER ${target}:",
        '--------------------------------------------------',
        revisedS.join(),
        '--------------------------------------------------',
      ].join('<br/>'))
      s = revisedS.join()
    } else {
      paragraph("No matcher for ${target}")
    }
  }
  return s
}

void processString() {
  //populatePatternAndMatcherCaches()
  String s = getSampleData()
  s = replaceTrivial(s)
  s = matchAndReplace(s)
  paragraph s
}

// X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X

ArrayList replaceBlock(ArrayList blocklist, Integer pos, ArrayList replacement) {
  blocklist[pos] = replacement
  return blocklist.flatten()
}

ArrayList applyPatternNameToBlock(String patternName, ArrayList block) {
  ArrayList newBlocks = []
  String blkType = block[0]
  String blkData = block[1]
  ArrayList orderedPatterns = blocksToOrderedPatterns[blkType]
  Pattern pattern = patterns[patternName]
  Matcher m = (blkData =~ pattern)
  // Instead of looping, do a "one and done"
  if (m.find()) {
    if (m.start() > 0) {
      nextBlocks << ['raw', blkData.substring(0, m.start())]
    }
    nextBlocks << [patternName, "<b>${m.group(1)}</b>"]
    if (m.end() != m.regionEnd()) {
      nextBlocks << ['raw', blkData.substring(m.end(), m.regionEnd())]
    }
  }
  return newBlocks
}

String redEllipse() {
  return '''<span style='color: red;'><b>...</b></span>'''
}

String summarizeString(String sArg) {
  // Ensure the summarized string is <= 100 chars.
  s = sArg.replace('\n', '␤')
  Integer l = s.size()
  return (l > 60)
    ? "${s.substring(0, 29)}${redEllipse()}${s.substring(l - 29, l - 1)}"
    : s
}

void showBlocks(ArrayList blocks) {
  if (blocks) {
    blocks.eachWithIndex { block, i ->
      String type = block[0]
      String data = block[1]
      data = data.replace('\n', '␤')
      paragraph("[blk #${i} ${type}] ${summarizeString(data)}")
    }
  } else {
    paragraph('showBlocks() has null argument')
  }
}

// MORE METHODS

void installed() {
  // Called when a bare device is first constructed.
  f()
}

void updated() {
  // Called when a human uses the Hubitat GUI's Device drilldown page to edit
  // preferences (aka settings) AND presses 'Save Preferences'.
  f()
}

void f() {
  log.info('f() has nothing to do for now.')
}

// Sample Data
String getSampleData() {
  String s1 = 'This is a test of the emergency broadcast system.'
  List list1 = ['one', 'two', 'three', 'four', 'five']
  Map map1 = [a: 'apple', b: 'banana', g: 'grape', l:'lemon', o: 'orange']
  String testData = '''
1234567 101234567 201234567 301234567 401234567 501234567 601234567 701234567

1234567 101234567 201234567 30

1234567 101234567 20

= First *Header* is #1
normal paragraph -- 1
== Second _Header_ is #2
normal paragraph 2

* Monday Tuesday Wednesday *Thursday* Friday
** Apples _Bananas_ Oranges _Grapes_
*** Cats _*Dogs Birds Turtles*_ Rabbits Fish

=== This is `Header 3`
normal paragraph 3

normal paragraph 4 that keeps on `going and going and going` and going and going
and going and going and going and going and ... going and going and going and
going and going.

descriptive list1::
descriptive list information ... one two three four five

descriptive list2::
* list2 bullet 1
* list2 bullet 1
* list2 bullet 1

 This text should be presented 'as is' with no formatting. This text should be
 presented 'as is' with no formatting. This text should be presented 'as is'
 with no formatting. This text should be presented 'as is' with no formatting.
 This text should be presented 'as is' with no formatting. This text should be
 presented 'as is' with no formatting. This text should be presented 'as is'
 with no formatting.

.This acts as a simple header

This is a paragraph that runs for more than one line. Here is a It's just here
to occupy space and flesh-out testing.

.Special Text
Copyright(C),TemporaryMark(TM),Registered(R),EmDash--,Elipse...,
RightArrow->,LeftArrow<-

[  cols = 3 ]
|===
|row 1 col 1
|row 1 col 2 +
more row 1 col 2
|row 1 col 3
|row 2 col 1 |row 2 col 2
|row 2 col 3
|row 3 col 1 +
More for row3 col1
|row 3 col 2 |row 3 col 3
|===

Let's test a few inlines strings. First a true string: >s1<. Next a list: >list1<.
Nest a sample map: >map1<. That's it for now.

'''
}
